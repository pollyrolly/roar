<html>
<head>
 <meta charset="utf-8"/>
 <style>
 
 body{
  margin: 0;
}

#header{
 
 background-color: #334a94;
 height: 70px;
 color: #FFFFFF;
 text-align: left;
 padding-left: 20px;
 padding-top: 20px;
 font-family: "Arial";
}
 
#nav{
 background-color: #334a94;
 height: 650px;
 width: 250px;
 float: left;
 padding: 5px;
}
 
#section{
 width: 400px;
 height: 650px;
 float: left;
 padding: 30px;
}

h2{
  font-family: "Tahoma";
}

p{
  font-family: "Palatino Linotype";
}
 
#footer{
 background-color: #334a94;
 color: #FFFFFF;
 clear: both;
 text-align: center;
 padding: 20px;
}


.tab ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    width: 100%;
    background-color: #334a94;
}

li  {
  font-family: Calibri;
  font-size: 14pt;
  font-style:none;
  display: block;
  color: #FFFFFF;
  padding: 8px 0 8px 16px;
  text-decoration: none;
}

li:active  {
    background-color: #4CAF50;
    color: #FFFFFF;
	
}

li:hover {
    background-color: #786ED4;
    color: #000000;
}

.AWS-logo {
 
  top: 1px;
  height: 40px;
  background: #5555557a;
  
}

.AWS {
  position: absolute;
  width: 40px;
  height: 20px;
  top: 15px;
  left: 5px;
  
}

.AWS-logo h2 {
	position: absolute;
	top: 1px;
	left: 40px;
	
}




.smile {
  position: absolute;
  width: 40px;
  height: 8px;
  top: 30px;
  left: 15px;;
}

.tab {
  float: left;
  border: 1px solid #ccc;
  background-color: #f1f1f1;
  width: 40%;
  height: 650px;
  position: relative;
  overflow: auto;
}

/* Style the buttons inside the tab */
.tab button {
  display: block;
  background-color: inherit;
  color: black;
  padding: 0px 16px;
  width: 100%;
  border: none;
  outline: none;
  text-align: left;
  cursor: pointer;
  transition: 0.3s;
  font-size: 17px;
}
.canvas-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 10px;
            width: 620px;
            margin: 0 auto;
}

.canvas {
    border: 1px solid #000;
    width: 80%;
    height: 80%;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: #ddd;
}

/* Create an active/current "tab button" class */
.tab button.active {
  background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
  float: left;
  padding: 0px 30px;
  border: 1px solid #ccc;
  width: 75%;
  border-left: none;
  height: 100%;
  overflow: auto;
}

.container {
            width: 80%;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
}
table {
            width: 100%;
            border-collapse: collapse;
}
th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
}
th {
            background-color: #f2f2f2;
}

</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

</head>
<body>
 
<div id="header">
 <img class="AWS" src="https://a0.awsstatic.com/libra-css/images/logos/aws_smile-header-desktop-en-white_59x35@2x.png"  alt=""/> 
 <h2>Redshift Cluster Health Review Report - conducted on: 2024-11-04 11:44:16</h2>
</div>
 
<div id="nav" class="tab">
  <ul >
     <li class="tablinks" id="#tab_0" onclick="openTab(event, 'tab_0')">ClusterDetails</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_1')">Statistics</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_2')">ATOWorkerActions</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_3')">AlterTableRecommendations</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_4')">ConcurrencyScalingUsage</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_5')">CopyPerformance</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_6')">DataShareConsumerUsage</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_7')">DataShareProducerObject</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_8')">MaterializedView</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_9')">NodeDetails</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_10')">QueueHealth</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_11')">SpectrumPerformance</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_12')">TableAlerts</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_13')">TableInfo</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_14')">Top50QueriesByDiskSpill</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_15')">Top50QueriesByRunTime</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_16')">UsagePattern</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_17')">WLMConfig</a></li>
     <li class="tablinks" onclick="openTab(event, 'tab_18')">WLMandCommit</a></li>
	 <li class="tablinks" onclick="openTab(event, 'tab_19')">WorkloadEvaluation</a></li>
     
	 
  </ul>
</div>

<div id="tab_0" class="tabcontent" data-tab-info>
  <div style="width: 80%; margin: 0 auto;">
  <table border="1" class="dataframe">
   
      <th>AccountId</th>
      <th>ClusterId</th>
      <th>ClusterName</th>
      <th>InstanceType</th>
      <th>NumberDataNodes</th>
      <th>ClusterVersion</th>
      
      <tr>
      <td>47939527907</td>
      <td>35718913</td>
      <td>reignitepoc</td>
      <td>ra3.xlplus</td>
      <td>2</td>
      <td>p180</td>
      </tr>
    </table>		
	<br>
	<br>
  </div>

<div>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>18-Category Stacked Bar Chart with Pastel Colors</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </div>
  <div style="width: 80%; margin: 0 auto;">
      <canvas id="stackedBarChart"></canvas>
  </div>

  <script>
  function hsl_to_rgb(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      if (s == 0) {
          r = g = b = l;
      } else {
          function hue2rgb(p, q, t) {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
          }

          let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          let p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  function rgb_to_hex(r, g, b) {
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function generate_distinct_pastel_colors(count) {
      let colors = [];
      let hue_step = 360 / count;
      for (let i = 0; i < count; i++) {
          let hue = Math.floor(i * hue_step);
          let saturation = 65 + (i % 5);  // Slight variation in saturation
          let lightness = 75 + (i % 5);  // Slight variation in lightness
          let rgb_color = hsl_to_rgb(hue, saturation, lightness);
          let hex_color = rgb_to_hex(rgb_color[0], rgb_color[1], rgb_color[2]);
          colors.push(hex_color);
      }
      return colors;
  }

  const pastelColors = generate_distinct_pastel_colors(18);

  const ctx = document.getElementById('stackedBarChart').getContext('2d');
  
  // a list of categories
  const categories = ['apple', 'banana', 'orange', 'mango',
    'apple', 'banana', 'orange', 'mango',
    'apple', 'banana', 'orange', 'mango',
    'apple', 'banana', 'orange', 'mango',
    'apple', 'banana'
  ];

  const data = {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
      datasets: pastelColors.map((color, index) => ({
          label: categories[index],
          data: Array.from({length: 6}, () => Math.floor(Math.random() * 100)),
          backgroundColor: color,
          borderColor: color,
          borderWidth: 1
      }))
  };

  new Chart(ctx, {
      type: 'bar',
      data: data,
      options: {
          plugins: {
              title: {
                  display: true,
                  text: '18-Category Stacked Bar Chart with Pastel Colors'
              },
              legend: {
                  position: 'right',
                  labels: {
                      boxWidth: 12
                  }
              }
          },
          responsive: true,
          scales: {
              x: {
                  stacked: true,
              },
              y: {
                  stacked: true
              }
          }
      }
  });
  </script>


</div>
 
<div id="tab_1" class="tabcontent" data-tab-info>
  <table border="1" class="dataframe">

  <div class="container">
    <canvas id="barChart" ></canvas>
  </div>
  <div class="container">
    <canvas id="lineChart" ></canvas>
  </div>
  <div class="container">
	  <canvas id="sigChart"></canvas>
  </div>
	
	<script>
	var xValues = ["Table Alerts", "Table Info", "AlterTable Recommendations", "Spectrun Performance"];
	var yValues = [27, 15, 3, 3] ;
	var barColors = ["blue", "red","green","yellow"];

	new Chart("barChart", {
	  type: "bar",
	  data: {
		labels: xValues,
		datasets: [{
		  backgroundColor: barColors,
		  data: yValues,
		}]
	  },
	  options: {
    plugins: {
              title: {
                  display: true,
                  text: 'Top categories with signals'
              },
              legend: {
                  position: 'right',
                  labels: {
                      boxWidth: 12
                  }
              }
          },
          responsive: true,
	  }
	});
	
	const xlineValues = ['4-Feb','11-Feb','18-Feb','26-Feb','8-Mar','16-Mar','5-Apr'];
	
	

	new Chart("lineChart", {
	  type: "line",
	  data: {
		labels: xlineValues,
		datasets: [{ 
		  data: [16, 13,13, 9, 7,6,3],
		  borderColor: "red",
		  label: "Alter Table Recommendations",
		  fill: false
		}, { 
		  data: [8,9,11,8, 6,6,14],
		  borderColor: "green",
		  label: "Copy Performance",
		  fill: false
		}, { 
		  data: [7,5,5,3,2,2,1],
		  borderColor: "blue",
		  label: "Queue Health",
		  fill: false
		},		
		{ 
		  data: [15,13,13,10,8,5,3],
		  borderColor: "yellow",
		  label: "Spectrum Performance",
		  fill: false
		},
		{ 
		  data: [17,15,15,14,14,12,27],
		  borderColor: "grey",
		  label: "Table Alerts",
		  fill: false
		},
		{ 
		  data: [21,18,21,24,16,15,15],
		  borderColor: "purple",
		  label: "Table Info",
		  fill: false
		}
		]
	  },
	  options: {
    responsive: true,
		legend: {
			display: true,
			position: "right"
			},
    
		title: {
		  text: "Category Trends over 3 months"
		}
	  }
	});
	
	
	const xSigValues = ['4-Feb','11-Feb','18-Feb','26-Feb','8-Mar','16-Mar','5-Apr'];
	
	

	new Chart("sigChart", {
	  type: "line",
    responsive: true,
	  data: {
		labels: xSigValues,
		datasets: [{ 
		  data: [8,9,11,8, 6,6,14],
		  borderColor: "blue",
		  label: "Copy Performance",
		  fill: false
		},
		{ 
		  data: [17,15,15,14,14,12,27],
		  borderColor: "orange",
		  label: "Table Alerts",
		  fill: false
		}
		]
	  },
	  options: {
    responsive: true,
		legend: {
			display: true,
			position: "right"
			},
		title: {
		  text: "Categories with increased Signals"
		}
	  }
	});
	</script>
	
</table>
</div>

<div id="tab_2" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_3" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_4" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_5" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_6" class="tabcontent" data-tab-info  >
  <p>No recommendations at this time</p>
</div>
<div id="tab_7" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_8" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_9" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>has under-utilized storage</td>
      <td>storage_utilization_pct < 40 and not node_type.str.startswith('ra3')</td>
      <td>To save cost, remove extra compute nodes using elastic or classic resize<br></td>
      <td>You many have more compute than you need.  If you can reduce the size of your cluster and maintain your SLAs, you may be able to save money.<br><br>In addition, enable the concurrency scaling feature and leverage the 1 hour free credit / day on a given WLM queue. Apply the necessary concurrency scaling usage limits.<br>Use of concurrency scaling allows the cluster to handle spiky compute needs and allow for queries in WLM queues in which its enabled to get consistent performance.<br><br>Blogs:<ul><a href='https://aws.amazon.com/blogs/big-data/accelerate-resize-and-encryption-of-amazon-redshift-clusters-with-faster-classic-resize/' target='_blank'> Accelerate resize and encryption of Amazon Redshift clusters with Faster Classic Resize</a></ul>Documentation: <ul><a href='https://docs.aws.amazon.com/redshift/latest/mgmt/managing-cluster-operations.html#elastic-resize' target='_blank'>Elastic Resize operation</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/concurrency-scaling-queues.html' target='_blank'>Configuring concurrency scaling queues</a><a href='https://docs.aws.amazon.com/redshift/latest/mgmt/managing-cluster-usage-limits.html' target='_blank'>Managing usage limits in Amazon Redshift</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<div id="tab_10" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>hours/queues with a high compile count</td>
      <td>total_compile_count > 10</td>
      <td>To reduce compile overhead, avoid drop/create operations in favor of delete/copy/insert<br></td>
      <td>High compile count can be caused by queries executed against new tables.<br><br>Blogs: <ul><a href='https://aws.amazon.com/blogs/big-data/fast-and-predictable-performance-with-serverless-compilation-using-amazon-redshift/' target ='_blank'>Fast and predictable performance with serverless compilation using Amazon Redshift</a></ul>Documentation: <ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/c-query-performance.html' target ='_blank'>Factors affecting query performance</a></ul><br></td>
    </tr>
    <tr>
      <td>2</td>
      <td>hours/queues with a high nl join row count</td>
      <td>total_nl_join_row_count > 1000</td>
      <td>To improve query performance, remove nested loop joins (cross-joins)<br></td>
      <td>Review queries that makes use of cross-joins and remove them if possible by adding a join condition.Documentation: <ul><a href=https://docs.aws.amazon.com/redshift/latest/dg/query-performance-improvement-opportunities.html#nested-loop' target='_blank'>Query Performance Improvement Opportunities</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<div id="tab_11" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_12" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_13" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>large tables with skew</td>
      <td>skew_rows >= 4 and not diststyle.str.startswith('AUTO')</td>
      <td>To improve query performance, choose the best distribution style<br></td>
      <td>Heavy skew (where the ratio of the number of rows on a slice is more than 4x of another slice) can cause queries to perform slower as they are waiting on the compute node with the most data to complete before returning the result set. If the first node is skewed, this may be due to using a distribution key containing nulls. To change the column used as a distribution key, the following command can be executed:<br><code>ALTER TABLE [table_name] ALTER DISTSTYLE KEY DISTKEY <high_cardinality_column>;</code><br><br>For small tables (< 5mill rows) e.g. reference or dimension tables that are frequently used in JOINS consider an ALL distribution style which puts a complete copy of the table on each node. <br><code>ALTER TABLE [table_name] ALTER DISTSTYLE AUTO;</code><br><br>To manage the distribution style automatically, it's recommended that you create your tables with DISTSTYLE AUTO. Amazon Redshift initially assigns ALL distribution to a small table, then changes to EVEN distribution when the table grows larger. It automatically monitors the workload on the cluster and over time may change the distribution of your data to have a KEY-based distribution style. To change the distribution style of a table, the following command can be executed:<br><code>ALTER TABLE [table_name] ALTER DISTSTYLE AUTO;</code><br><br>Use of temporal columns such as sold_date, event_date etc whenever there is a minimal or peak activity will likely cause a huge variance compared to normal activity that generates that data thus causing data skewness. A low skew value indicates that table data is properly distributed. If a table has a skew value of 4.00 or higher, consider modifying its data distribution style.<br><br>Blog:<ul> <a href='https://aws.amazon.com/blogs/big-data/amazon-redshift-engineerings-advanced-table-design-playbook-distribution-styles-and-distribution-keys/' target='_blank'>Amazon Redshift Engineering Advanced Table Design Playbook: Distribution Styles and Distribution Keys</a><a href='https://aws.amazon.com/blogs/big-data/automate-your-amazon-redshift-performance-tuning-with-automatic-table-optimization/' target='_blank'>Automate your Amazon Redshift performance tuning with automatic table optimization</a></ul>Documentation: <ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/c_best-practices-best-dist-key.html' target='_blank'>Choose the best distribution style</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/t_Creating_tables.html#ato-enabling' target='_blank'>Enabling automatic table optimization</a></ul><br></td>
    </tr>
    <tr>
      <td>7</td>
      <td>small tables without an ALL distribution</td>
      <td>not diststyle.str.contains('ALL')</td>
      <td>To improve query performance, choose the best distribution style<br></td>
      <td>Heavy skew (where the ratio of the number of rows on a slice is more than 4x of another slice) can cause queries to perform slower as they are waiting on the compute node with the most data to complete before returning the result set. If the first node is skewed, this may be due to using a distribution key containing nulls. To change the column used as a distribution key, the following command can be executed:<br><code>ALTER TABLE [table_name] ALTER DISTSTYLE KEY DISTKEY <high_cardinality_column>;</code><br><br>For small tables (< 5mill rows) e.g. reference or dimension tables that are frequently used in JOINS consider an ALL distribution style which puts a complete copy of the table on each node. <br><code>ALTER TABLE [table_name] ALTER DISTSTYLE AUTO;</code><br><br>To manage the distribution style automatically, it's recommended that you create your tables with DISTSTYLE AUTO. Amazon Redshift initially assigns ALL distribution to a small table, then changes to EVEN distribution when the table grows larger. It automatically monitors the workload on the cluster and over time may change the distribution of your data to have a KEY-based distribution style. To change the distribution style of a table, the following command can be executed:<br><code>ALTER TABLE [table_name] ALTER DISTSTYLE AUTO;</code><br><br>Use of temporal columns such as sold_date, event_date etc whenever there is a minimal or peak activity will likely cause a huge variance compared to normal activity that generates that data thus causing data skewness. A low skew value indicates that table data is properly distributed. If a table has a skew value of 4.00 or higher, consider modifying its data distribution style.<br><br>Blog:<ul> <a href='https://aws.amazon.com/blogs/big-data/amazon-redshift-engineerings-advanced-table-design-playbook-distribution-styles-and-distribution-keys/' target='_blank'>Amazon Redshift Engineering Advanced Table Design Playbook: Distribution Styles and Distribution Keys</a><a href='https://aws.amazon.com/blogs/big-data/automate-your-amazon-redshift-performance-tuning-with-automatic-table-optimization/' target='_blank'>Automate your Amazon Redshift performance tuning with automatic table optimization</a></ul>Documentation: <ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/c_best-practices-best-dist-key.html' target='_blank'>Choose the best distribution style</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/t_Creating_tables.html#ato-enabling' target='_blank'>Enabling automatic table optimization</a></ul><br></td>
    </tr>
    <tr>
      <td>7</td>
      <td>small tables with a sort key</td>
      <td>sortkey1 != ''</td>
      <td>To improve query performance, choose a better sort key<br></td>
      <td>For large tables, adding a sort key can speed up queries with predicates. Review commonly filtered fields and add a sort key:<br><code>ALTER TABLE [table_name] ALTER SORTKEY ([column1], [columnN])</code><br><br>For small tables (&lt;5 million rows or less), sort keys are not effective and will add maintenance and storage overhead:<br><code>ALTER TABLE [table_name] ALTER SORTKEY NONE;</code><br><br>For unknown table sizes or access pattern, you can set the sort key to AUTO which allows Redshift to define the optimal sort key:<br><code>ALTER TABLE [table_name] ALTER SORTKEY AUTO;</code><br></td>
    </tr>
    <tr>
      <td>3</td>
      <td>tables with low column compression</td>
      <td>encoded_column_pct < 80</td>
      <td>If you are running out of storage or to reduce I/O overhead, review compression encodings<br></td>
      <td>Compression is a column-level operation that reduces the size of data when it is stored. Compression conserves storage space and reduces the size of data that is read from storage, which reduces the amount of disk I/O and therefore improves query performance. As a best practice, leverage AZ64 for numeric and data data types and ZSTD for character data types where possible or use ENCODE AUTO to automatically manage the compression encoding for all columns in the table. <br><br>For monitoring actions of automatic table optimization, a system view <a href='https://docs.aws.amazon.com/redshift/latest/dg/r_SVV_ALTER_TABLE_RECOMMENDATIONS.html' target='_blank'>SVV_ALTER_TABLE_RECOMMENDATIONS</a> records the current Amazon Redshift Advisor recommendations for tables while <a href='https://docs.aws.amazon.com/redshift/latest/dg/r_SVL_AUTO_WORKER_ACTION.html' target='_blank'>SVL_AUTO_WORKER_ACTION</a> shows an audit log of all the actions taken by the Amazon Redshift, and the previous state of the table.<br><br>To change the encoding of the table to AUTO, the following command can be executed:<br><code>ALTER TABLE [table_name] ALTER ENCODE AUTO;<br></code><br>Documentation: <br><ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/t_Compressing_data_on_disk.html target='_blank'>Working with column compression</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/t_Verifying_data_compression.html' target='_blank'>Testing compression encodings</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<div id="tab_14" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_15" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>long running queries using Nested Loop Joins</td>
      <td>alert.str.contains('NL')</td>
      <td>To set query performance boundaries on workloads, add QMR rules <br>To improve query performance, remove nested loop joins (cross-joins)<br></td>
      <td>Query monitoring rules (QMR) define metrics-based performance boundaries for WLM queues and specify what action to take when a query goes beyond those boundaries. For example, to track poorly designed queries, you might have a rule that logs queries that contain nested loops or executes for more than 2 hours. You can define up to 25 rules for each queue, with a limit of 25 rules for all queues.. You can start with Query monitoring rules templates.<br>WLM evaluates metrics every 10 seconds. If more than one rule is triggered during the same period, WLM initiates the most severe action; abort, then hop, then log.<br>The most common metrics where QMR can protect your system include:<br>* query_execution_time - identifies sub-optimal table or query design<br>* query_temp_blocks_to_disk - identifies queries using more than available memory which write intermediate results to disk (spilled memory).<br>* spectrum_scan_size_mb / spectrum_scan_row_count - a large scan may mean there is no partition pruning applied and the operation will be both costly and time consuming<br>* nested_loop_join_row_count - joins without a join condition that result in the Cartesian product of two tables are the slowest of the possible join types, use the most memory and may lead to disk spill<br>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html' target='_blank'>WLM query monitoring rules</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-templates' target='_blank'>Query monitoring rules templates</a></ul><br>Review queries that makes use of cross-joins and remove them if possible by adding a join condition.Documentation: <ul><a href=https://docs.aws.amazon.com/redshift/latest/dg/query-performance-improvement-opportunities.html#nested-loop' target='_blank'>Query Performance Improvement Opportunities</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<div id="tab_16" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_17" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>queues do not have total memory = 100</td>
      <td>select sum(cluster_memory_pct) from df || < 100</td>
      <td>Re-allocate your memory distribution to add up to 100%<br></td>
      <td>When using manual WLM total memory allocation should equal 100% when using manual WLM. Allocating less than 100% may result in unpredictable query performance and/or inefficient use of cluster resources..<br><br>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-defining-query-queues.html' target='_blank'>Implementing manual WLM</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-defining-query-queues.html#wlm-memory-percent' target='_blank'>WLM memory percent to use</a></ul><br></td>
    </tr>
    <tr>
      <td>1</td>
      <td>uses single WLM queue</td>
      <td>select count(1) from df where service_class_category = 'Manual WLM' OR  service_class_category = 'Auto WLM' || == 1</td>
      <td>To have better visibility on resource usage by workload and optimize resource allocation, create separate query queues for each workload<br></td>
      <td>When you define multiple query queues, you can route queries to the appropriate queues at runtime<br>For example query queues can be defined for each type of workload as per below:<br>- BI / Dashboard workload<br>- ETL / Data Ingestion workload<br>- Data Science workload<br>- Adhoc workload<br>- Application workload<br><br>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-queue-assignment-rules.html' target='_blank'>WLM queue assignment rules</a></ul><br></td>
    </tr>
    <tr>
      <td>1</td>
      <td>Concurrency scaling is not enabled</td>
      <td>select count(1) from df where concurrency_scaling = 'auto' || == 0</td>
      <td>For additional scalability, enable the concurrency scaling<br></td>
      <td>Use of concurrency scaling allows the cluster to handle spiky compute needs and allow for queries in WLM queues in which its enabled to get consistent performance. Concurrency scaling is available 1 hour free per day. Additionally usage limits can be applied to manage costs.<br><br>Blogs:<ul><a href='https://aws.amazon.com/blogs/big-data/manage-and-control-your-cost-with-amazon-redshift-concurrency-scaling-and-spectrum/' target='_blank'>Manage and control your cost with Amazon Redshift Concurrency Scaling and Spectrum</a></ul>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/concurrency-scaling.html' target='_blank'>Working with concurrency scaling</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/concurrency-scaling-queues.html' target='_blank'>Configuring concurrency scaling queues</a><a href='https://docs.aws.amazon.com/redshift/latest/mgmt/managing-cluster-usage-limits.html' target='_blank'>Managing usage limits in Amazon Redshift</a></ul>Videos:<ul><a href='https://www.youtube.com/watch?v=-2yQsI9xJKQ' target='_blank'>Amazon Redshift Concurrency Scaling</a></ul><br></td>
    </tr>
    <tr>
      <td>1</td>
      <td>all query queues having the same query priority</td>
      <td>select count(distinct queue_priority) from df || == 1</td>
      <td>To ensure queries get resources based on importance, set priorities for each WLM queue<br></td>
      <td>Not all queries are of equal importance, and often performance of one workload or set of users might be more important.<br>When auto WLM is enabled, you can define the relative importance of queries in a workload by setting a priority value. The priority is specified for a queue and inherited by all queries associated with the queue. Amazon Redshift uses the priority when letting queries into the system, and to determine the amount of resources allocated to a query.<br>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/query-priority.html' target='_blank'>Query priority</a></ul><br></td>
    </tr>
    <tr>
      <td>1</td>
      <td>no query monitoring rules (QMR) defined</td>
      <td>select sum(qmr_rule_count) from df || == 0</td>
      <td>To set query performance boundaries on workloads, add QMR rules <br></td>
      <td>Query monitoring rules (QMR) define metrics-based performance boundaries for WLM queues and specify what action to take when a query goes beyond those boundaries. For example, to track poorly designed queries, you might have a rule that logs queries that contain nested loops or executes for more than 2 hours. You can define up to 25 rules for each queue, with a limit of 25 rules for all queues.. You can start with Query monitoring rules templates.<br>WLM evaluates metrics every 10 seconds. If more than one rule is triggered during the same period, WLM initiates the most severe action; abort, then hop, then log.<br>The most common metrics where QMR can protect your system include:<br>* query_execution_time - identifies sub-optimal table or query design<br>* query_temp_blocks_to_disk - identifies queries using more than available memory which write intermediate results to disk (spilled memory).<br>* spectrum_scan_size_mb / spectrum_scan_row_count - a large scan may mean there is no partition pruning applied and the operation will be both costly and time consuming<br>* nested_loop_join_row_count - joins without a join condition that result in the Cartesian product of two tables are the slowest of the possible join types, use the most memory and may lead to disk spill<br>Documentation:<ul><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html' target='_blank'>WLM query monitoring rules</a><a href='https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-templates' target='_blank'>Query monitoring rules templates</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<div id="tab_18" class="tabcontent" data-tab-info>
  <p>No recommendations at this time</p>
</div>
<div id="tab_19" class="tabcontent" data-tab-info>
  <p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Count</th>
      <th>Signal</th>
      <th>Criteria</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Evaluate Workload for Serverless. Cluster is busy less than 75% of the time in a day.</td>
      <td>select sum(total_query_minutes_in_day)/1440 from df  || *100 < 75</td>
      <td>For better price performance, leverage Redshift serverless.<br></td>
      <td>Redshift serverless provides the same or better price performance when compared to on demand especially with intermittent workloads. This is possible because of its ability to auto pause and resume  so you only pay for the times the cluster is running.<br><br>Documentation:<ul><a href=https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-serverless.html target='_blank'>What is Amazon Redshift Serverless?</a><a href=https://docs.aws.amazon.com/redshift/latest/mgmt/serverless-billing.html target='_blank'>Serverless Billing</a></ul>Demo Video:<ul><a href=https://www.youtube.com/watch?v=XcRJjXudIf8 target='_blank'>Getting started with Amazon Redshift Serverless</a><a href=https://www.youtube.com/watch?v=JBPpmMq9OS8 target='_blank'>Amazon Redshift Serverless - Pay for Use Cost Calculation</a></ul><br></td>
    </tr>
  </tbody>
</table></p>
</div>
<script>
function openTab(evt, tabid) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the link that opened the tab
  document.getElementById(tabid).style.display = "block";
  evt.currentTarget.className += " active";
} 
document.getElementById("#tab_0").click();
</script>
</body>
</html>